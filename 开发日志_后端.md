# 后端开发工作日志

> 记录所有后端相关的开发、问题和解决方案

---

## 📅 2025年10月13日 - 数据库字段映射问题修复

### 🐛 问题1: 数据库字段映射错误

**问题现象：**
- 管理员获取商品列表返回 500 错误
- 用户列表查询失败

**错误日志：**
```
Error: Unknown column 'c.category_name' in 'field list'
Error: Unknown column 'u.status' in 'field list'
Error: Unknown column 'oi.order_item_id' in 'field list'
```

**问题原因：**

数据库实际字段与代码中使用的字段名不匹配：

```bash
# categories 表实际字段
mysql> DESCRIBE categories;
+-------------+--------------+
| Field       | Type         |
+-------------+--------------+
| category_id | int          |
| name        | varchar(100) |  ← 不是 category_name
| parent_id   | int          |
| sort_order  | int          |
+-------------+--------------+

# users 表（没有 status 字段）
mysql> DESCRIBE users;
+---------------+---------------+
| Field         | Type          |
+---------------+---------------+
| user_id       | bigint        |
| username      | varchar(50)   |
| email         | varchar(100)  |
| password_hash | varchar(255)  |
| phone         | varchar(20)   |
| avatar_url    | varchar(255)  |
| created_at    | timestamp     |
| updated_at    | timestamp     |
+---------------+---------------+
# 注意：没有 status 字段

# order_items 表
+---------------+---------------+
| item_id       | bigint        |  ← 不是 order_item_id
| order_id      | bigint        |
| product_id    | bigint        |
+---------------+---------------+
```

**解决方案：**

**修复1：商品管理控制器**

**文件：** `backend/src/controllers/admin-product.controller.ts`

```typescript
// ❌ 修改前
const [products] = await pool.query(
  `SELECT 
    p.*,
    c.category_name,  // 字段不存在
    (SELECT COUNT(*) FROM order_items oi 
     WHERE oi.product_id = p.product_id) as total_sales
   FROM products p
   LEFT JOIN categories c ON p.category_id = c.category_id
   ...`
);

// ✅ 修改后 - 使用别名
const [products] = await pool.query(
  `SELECT 
    p.*,
    c.name as category_name,  // 使用 AS 别名
    (SELECT COUNT(*) FROM order_items oi 
     WHERE oi.product_id = p.product_id) as total_sales
   FROM products p
   LEFT JOIN categories c ON p.category_id = c.category_id
   ...`
);
```

**修复2：用户管理控制器**

**文件：** `backend/src/controllers/admin-user.controller.ts`

```typescript
// ❌ 修改前
const [users] = await pool.query(
  `SELECT 
    u.user_id,
    u.username,
    u.email,
    u.phone,
    u.status,  // 字段不存在
    u.created_at,
    ...`
);

// ✅ 修改后 - 移除不存在的字段
const [users] = await pool.query(
  `SELECT 
    u.user_id,
    u.username,
    u.email,
    u.phone,
    u.created_at,
    ...`
);

// 同时移除 status 相关的 WHERE 条件
// ❌ if (status !== undefined) { whereClause += ' AND u.status = ?'; }
```

**修复3：管理员仪表盘控制器**

**文件：** `backend/src/controllers/admin.controller.ts`

```typescript
// 修复 order_items 字段名
// ❌ oi.order_item_id → ✅ oi.item_id

// 修复 products 图片字段
// ❌ p.image_url → ✅ p.main_image
```

---

### 🐛 问题2: 添加商品功能字段错误

**问题现象：**
- 前端调用添加商品 API 返回 500 错误
- 错误日志：`Unknown column 'image_url' in 'field list'`

**问题原因：**
- products 表的图片字段是 `main_image`
- 但代码使用了 `image_url`

**数据库表结构：**
```sql
CREATE TABLE products (
  product_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  title VARCHAR(200) NOT NULL,
  description TEXT,
  category_id INT,
  brand VARCHAR(100),
  price DECIMAL(10,2) NOT NULL,
  original_price DECIMAL(10,2),
  stock INT DEFAULT 0,
  main_image VARCHAR(255),  ← 正确字段名
  images JSON,
  ...
);
```

**解决方案：**

**文件：** `backend/src/controllers/admin-product.controller.ts`

```typescript
// createProduct 函数
export const createProduct = async (req: Request, res: Response) => {
  const {
    title,
    description,
    price,
    stock,
    category_id,
    brand,
    image_url,  // 前端传入的参数名
    status = 1
  } = req.body;

  // ❌ 修改前
  const [result] = await pool.query(
    `INSERT INTO products 
     (title, description, price, stock, category_id, brand, image_url, status, ...)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ...)`,
    [title, description, price, stock || 0, category_id, brand, image_url, status]
  );

  // ✅ 修改后 - 映射到正确的字段名
  const [result] = await pool.query(
    `INSERT INTO products 
     (title, description, price, stock, category_id, brand, main_image, status, ...)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ...)`,
    [title, description, price, stock || 0, category_id, brand, image_url, status]
  );
};

// updateProduct 函数同样修复
if (image_url !== undefined) {
  updates.push('main_image = ?');  // 使用正确的字段名
  values.push(image_url);
}
```

---

### ✨ 新增功能：获取分类列表 API

**背景：**
前端添加商品时需要分类列表，但没有对应的公开API。

**实现：**

**文件：** `backend/src/controllers/product.controller.ts`

```typescript
// 获取分类列表
static async getCategories(req: Request, res: Response) {
  try {
    const { getPool } = require('../database/mysql');
    const pool = getPool();
    
    const [categories] = await pool.query(
      `SELECT category_id, name, parent_id, sort_order 
       FROM categories 
       ORDER BY sort_order ASC, category_id ASC`
    );
    
    res.json(categories);
  } catch (error) {
    console.error('获取分类列表失败:', error);
    res.status(500).json({ error: '获取分类列表失败' });
  }
}
```

**路由配置：**

**文件：** `backend/src/routes/product.routes.ts`

```typescript
// ⚠️ 重要：路由顺序很关键！
// 特殊路由必须放在动态路由 /:id 之前

router.get('/categories', ProductController.getCategories);  // ✅ 在前
router.get('/hot', ProductController.getHotProducts);        // ✅ 在前
router.get('/', ProductController.list);
router.get('/:id', ProductController.getDetail);             // ✅ 在后

// ❌ 错误示例
router.get('/:id', ...);          // 会匹配 /categories
router.get('/categories', ...);   // 永远不会执行
```

---

## 📅 2025年10月29日 - 收藏和SKU功能实现

### ✨ 新功能1：收藏系统

#### 数据库设计

**新表：** `favorites`

```sql
CREATE TABLE favorites (
  favorite_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  product_id BIGINT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY uk_user_product (user_id, product_id),
  INDEX idx_user (user_id),
  INDEX idx_product (product_id)
) ENGINE=InnoDB;
```

**设计要点：**
- 唯一约束防止重复收藏
- 索引优化查询性能
- 简单高效的表结构

#### 后端实现

**1. 数据模型**

**文件：** `backend/src/models/favorite.model.ts`（140行）

```typescript
export class FavoriteModel {
  // 添加收藏
  static async add(userId: number, productId: number): Promise<number>
  
  // 取消收藏
  static async remove(userId: number, productId: number): Promise<boolean>
  
  // 检查是否已收藏
  static async isFavorited(userId: number, productId: number): Promise<boolean>
  
  // 获取用户收藏列表（带分页）
  static async getUserFavorites(userId: number, page: number, limit: number)
  
  // 批量检查收藏状态
  static async checkMultipleFavorites(userId: number, productIds: number[])
  
  // 获取收藏数量
  static async getFavoriteCount(userId: number): Promise<number>
  
  // 获取商品被收藏次数
  static async getProductFavoriteCount(productId: number): Promise<number>
}
```

**关键实现：**

```typescript
// 添加收藏 - 处理重复
static async add(userId: number, productId: number): Promise<number> {
  try {
    const result = await query<ResultSetHeader>(
      'INSERT INTO favorites (user_id, product_id) VALUES (?, ?)',
      [userId, productId]
    );
    return result.insertId;
  } catch (error: any) {
    // 如果是重复键错误，返回0
    if (error.code === 'ER_DUP_ENTRY') {
      return 0;
    }
    throw error;
  }
}

// 获取收藏列表 - 联表查询
static async getUserFavorites(userId: number, page: number, limit: number) {
  const offset = (page - 1) * limit;
  
  const favorites = await query(
    `SELECT 
      f.favorite_id,
      f.user_id,
      f.product_id,
      f.created_at,
      p.title,
      p.price,
      p.original_price,
      p.main_image,
      p.stock,
      p.status
    FROM favorites f
    LEFT JOIN products p ON f.product_id = p.product_id
    WHERE f.user_id = ?
    ORDER BY f.created_at DESC
    LIMIT ? OFFSET ?`,
    [userId, limit, offset]
  );
  
  // 获取总数
  const [countResult] = await query(
    'SELECT COUNT(*) as total FROM favorites WHERE user_id = ?',
    [userId]
  );
  
  return { favorites, total: countResult.total };
}
```

**2. 控制器**

**文件：** `backend/src/controllers/favorite.controller.ts`（155行）

```typescript
import { Response } from 'express';
import { FavoriteModel } from '../models/favorite.model';
import { AuthRequest } from '../middleware/auth';

// 添加收藏
export const addFavorite = async (req: AuthRequest, res: Response) => {
  const userId = req.user?.userId;
  const { product_id } = req.body;
  
  if (!product_id) {
    return res.status(400).json({ message: '商品ID不能为空' });
  }
  
  const favoriteId = await FavoriteModel.add(userId, product_id);
  
  if (favoriteId === 0) {
    return res.status(200).json({ 
      message: '该商品已在收藏夹中',
      already_favorited: true 
    });
  }
  
  res.json({ message: '收藏成功', favorite_id: favoriteId });
};

// 切换收藏状态（智能）
export const toggleFavorite = async (req: AuthRequest, res: Response) => {
  const userId = req.user?.userId;
  const { product_id } = req.body;
  
  const isFavorited = await FavoriteModel.isFavorited(userId, product_id);
  
  if (isFavorited) {
    await FavoriteModel.remove(userId, product_id);
    return res.json({ 
      message: '取消收藏成功',
      is_favorited: false 
    });
  } else {
    const favoriteId = await FavoriteModel.add(userId, product_id);
    return res.json({ 
      message: '收藏成功',
      is_favorited: true,
      favorite_id: favoriteId 
    });
  }
};
```

**3. 路由配置**

**文件：** `backend/src/routes/favorite.routes.ts`（30行）

```typescript
import express from 'express';
import { authMiddleware } from '../middleware/auth';
import {
  addFavorite,
  removeFavorite,
  toggleFavorite,
  checkFavorite,
  getUserFavorites,
  checkMultipleFavorites,
  getFavoriteCount
} from '../controllers/favorite.controller';

const router = express.Router();

// 所有收藏路由都需要认证
router.use(authMiddleware);

router.post('/', addFavorite);
router.delete('/:product_id', removeFavorite);
router.post('/toggle', toggleFavorite);
router.get('/check/:product_id', checkFavorite);
router.post('/check-multiple', checkMultipleFavorites);
router.get('/my', getUserFavorites);
router.get('/count', getFavoriteCount);

export default router;
```

**4. 主应用注册路由**

**文件：** `backend/src/index.ts`

```typescript
import favoriteRoutes from './routes/favorite.routes';

// API路由
app.use('/api/favorites', favoriteRoutes);
```

**API接口列表：**
- `POST /api/favorites` - 添加收藏
- `DELETE /api/favorites/:product_id` - 取消收藏
- `POST /api/favorites/toggle` - 切换收藏状态
- `GET /api/favorites/check/:product_id` - 检查单个商品
- `POST /api/favorites/check-multiple` - 批量检查
- `GET /api/favorites/my` - 获取收藏列表（分页）
- `GET /api/favorites/count` - 获取收藏数量

---

### ✨ 新功能2：商品SKU系统

#### 数据库设计

**新表：** `product_skus`

```sql
CREATE TABLE product_skus (
  sku_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  product_id BIGINT NOT NULL,
  sku_code VARCHAR(50) UNIQUE NOT NULL,
  specs JSON COMMENT 'SKU规格 {"颜色":"红色","尺寸":"M"}',
  price DECIMAL(10,2) NOT NULL,
  original_price DECIMAL(10,2),
  stock INT DEFAULT 0,
  image VARCHAR(255),
  status TINYINT DEFAULT 1 COMMENT '1:启用 0:禁用',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_product (product_id),
  INDEX idx_sku_code (sku_code),
  INDEX idx_status (status)
) ENGINE=InnoDB;
```

**设计特点：**
- SKU编码唯一性约束
- JSON格式存储灵活规格
- 独立的价格和库存
- 支持SKU级别的启用/禁用

#### 后端实现

**1. SKU数据模型**

**文件：** `backend/src/models/sku.model.ts`（225行）

```typescript
export class SKUModel {
  // 基础CRUD
  static async create(data: SKUData): Promise<number>
  static async createBatch(skus: SKUData[]): Promise<void>
  static async findById(skuId: number): Promise<ProductSKU | null>
  static async findBySKUCode(skuCode: string): Promise<ProductSKU | null>
  static async findByProductId(productId: number): Promise<ProductSKU[]>
  static async update(skuId: number, data: Partial<ProductSKU>): Promise<boolean>
  static async delete(skuId: number): Promise<boolean>
  static async deleteByProductId(productId: number): Promise<boolean>
  
  // 库存管理
  static async updateStock(skuId: number, quantity: number): Promise<boolean>
  static async decreaseStock(skuId: number, quantity: number): Promise<boolean>
  
  // 工具方法
  static async getLowestPriceSKU(productId: number): Promise<ProductSKU | null>
  static async getTotalStock(productId: number): Promise<number>
}
```

**关键实现：**

```typescript
// 批量创建 SKU
static async createBatch(skus: any[]): Promise<void> {
  if (skus.length === 0) return;
  
  const values = skus.map(sku => [
    sku.product_id,
    sku.sku_code,
    JSON.stringify(sku.specs),  // JSON序列化
    sku.price,
    sku.original_price || null,
    sku.stock,
    sku.image || null
  ]);
  
  const placeholders = skus.map(() => '(?, ?, ?, ?, ?, ?, ?)').join(', ');
  const flatValues = values.flat();
  
  await query(
    `INSERT INTO product_skus 
     (product_id, sku_code, specs, price, original_price, stock, image)
     VALUES ${placeholders}`,
    flatValues
  );
}

// JSON处理 - 读取时反序列化
static async findByProductId(productId: number): Promise<ProductSKU[]> {
  const results = await query(
    'SELECT * FROM product_skus WHERE product_id = ? AND status = 1',
    [productId]
  );
  
  // 将JSON字符串转换为对象
  return results.map(sku => ({
    ...sku,
    specs: typeof sku.specs === 'string' 
      ? JSON.parse(sku.specs) 
      : sku.specs
  }));
}

// 库存扣减（带并发控制）
static async decreaseStock(skuId: number, quantity: number): Promise<boolean> {
  const result = await query(
    'UPDATE product_skus SET stock = stock - ? WHERE sku_id = ? AND stock >= ?',
    [quantity, skuId, quantity]
  );
  return result.affectedRows > 0;  // 库存不足时返回false
}
```

**2. 商品控制器增强**

**文件：** `backend/src/controllers/product.controller.ts`

```typescript
// 商品详情自动包含SKU信息
static async getDetail(req: Request, res: Response) {
  const productId = parseInt(req.params.id);
  
  // 获取商品基本信息
  const product = await ProductModel.findById(productId);
  
  if (!product) {
    return res.status(404).json({ error: '商品不存在' });
  }
  
  // 获取SKU信息
  const skus = await SKUModel.findByProductId(productId);
  
  const productWithSKU = {
    ...product,
    skus: skus.length > 0 ? skus : undefined,
    has_sku: skus.length > 0
  };
  
  // 缓存5分钟
  await redis.setex(cacheKey, 300, JSON.stringify(productWithSKU));
  
  res.json({ product: productWithSKU });
}
```

**3. 管理后台SKU管理**

**文件：** `backend/src/controllers/admin-product.controller.ts`（新增170行）

```typescript
// 获取商品的所有SKU
export const getProductSKUs = async (req: Request, res: Response) => {
  const { productId } = req.params;
  const skus = await SKUModel.findByProductId(parseInt(productId));
  res.json({ skus });
};

// 创建SKU
export const createSKU = async (req: Request, res: Response) => {
  const { productId } = req.params;
  const { sku_code, specs, price, original_price, stock, image } = req.body;
  
  const skuId = await SKUModel.create({
    product_id: parseInt(productId),
    sku_code,
    specs,
    price,
    original_price,
    stock: stock || 0,
    image
  });
  
  // 记录操作日志
  await logAdminAction(...);
  
  res.status(201).json({ message: 'SKU创建成功', sku_id: skuId });
};

// 批量创建SKU
export const batchCreateSKUs = async (req: Request, res: Response) => {
  const { productId } = req.params;
  const { skus } = req.body;
  
  const skusWithProductId = skus.map(sku => ({
    ...sku,
    product_id: parseInt(productId)
  }));
  
  await SKUModel.createBatch(skusWithProductId);
  
  res.status(201).json({ 
    message: `成功创建${skus.length}个SKU`,
    count: skus.length 
  });
};

// 更新SKU
export const updateSKU = async (req: Request, res: Response)

// 删除SKU
export const deleteSKU = async (req: Request, res: Response)
```

**4. SKU管理路由**

**文件：** `backend/src/routes/admin-product.routes.ts`

```typescript
import { 
  getProductSKUs,
  createSKU,
  batchCreateSKUs,
  updateSKU,
  deleteSKU
} from '../controllers/admin-product.controller';

// SKU 管理路由
router.get('/:productId/skus', requirePermission('product:view'), getProductSKUs);
router.post('/:productId/skus', requirePermission('product:create'), createSKU);
router.post('/:productId/skus/batch', requirePermission('product:create'), batchCreateSKUs);
router.put('/skus/:skuId', requirePermission('product:edit'), updateSKU);
router.delete('/skus/:skuId', requirePermission('product:delete'), deleteSKU);
```

---

## 🐛 问题解决方案汇总

### 问题1: 环境配置 - 缺少.env文件

**错误：**
```
Error: Access denied for user 'root'@'192.168.65.1' (using password: NO)
```

**解决：**
创建 `backend/.env` 文件：
```env
NODE_ENV=development
PORT=3001
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=root123456
DB_NAME=ecommerce
REDIS_HOST=localhost
REDIS_PORT=6379
MONGODB_URI=mongodb://admin:admin123@localhost:27017/ecommerce?authSource=admin
JWT_SECRET=your_development_jwt_secret_key
JWT_EXPIRES_IN=7d
```

---

### 问题2: TypeScript类型错误

**错误：**
```
error TS2339: Property 'user' does not exist on type 'Request'
```

**原因：**
使用了 Express 的普通 `Request` 类型，但访问了自定义的 `user` 属性。

**解决：**
```typescript
// ❌ 错误写法
import { Request, Response } from 'express';
export const handler = async (req: Request, res: Response) => {
  const userId = req.user?.userId;  // 类型错误
};

// ✅ 正确写法
import { Response } from 'express';
import { AuthRequest } from '../middleware/auth';
export const handler = async (req: AuthRequest, res: Response) => {
  const userId = req.user?.userId;  // 类型正确
};
```

**AuthRequest 定义：**
```typescript
// middleware/auth.ts
export interface AuthRequest extends Request {
  userId?: number;
  user?: any;
}

export function authMiddleware(
  req: AuthRequest, 
  res: Response, 
  next: NextFunction
) {
  const token = req.headers.authorization?.replace('Bearer ', '');
  if (!token) {
    return res.status(401).json({ error: '未登录' });
  }
  
  const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
  req.userId = decoded.userId;
  req.user = decoded;
  next();
}
```

**最佳实践：**
- 所有使用认证的控制器统一使用 `AuthRequest`
- 在 middleware 中定义扩展的 Request 类型
- 导出类型供其他模块使用

---

### 问题3: Nodemon缓存导致代码不更新

**现象：**
- 修改代码后 nodemon 显示重启
- 但仍然报旧的编译错误
- 新代码不生效

**原因：**
- ts-node 缓存了编译结果
- nodemon 没有检测到文件真正变化

**解决方案：**

**方法1：清除缓存**
```bash
rm -rf backend/node_modules/.cache
rm -rf backend/.ts-node
rm -rf backend/dist
```

**方法2：触发文件变化**
```bash
touch backend/src/controllers/favorite.controller.ts
```

**方法3：强制重启**
在 nodemon 运行的终端输入 `rs` 并按回车

**方法4：完全重启**
```bash
# Ctrl+C 停止
npm run dev  # 重新启动
```

**推荐流程：**
```bash
# 彻底解决
pkill -9 node                                    # 停止所有Node进程
rm -rf backend/node_modules/.cache backend/.ts-node  # 清除缓存
cd backend && npm run dev                        # 重新启动
```

---

### 问题4: Docker服务管理

**错误：**
```
Cannot connect to the Docker daemon
ECONNREFUSED 127.0.0.1:3306
```

**原因：**
- Docker Desktop 未启动
- MySQL 容器未运行

**解决：**

**启动Docker服务：**
```bash
# 1. 确保 Docker Desktop 运行
# 2. 启动所有服务
docker-compose up -d

# 3. 等待MySQL就绪（约30秒）
sleep 30

# 4. 验证服务状态
docker-compose ps
```

**开发模式最佳实践：**
```bash
# 只运行数据库服务，应用本地运行
docker stop ecommerce-backend ecommerce-frontend

# 后端本地运行（便于调试和热更新）
cd backend && npm run dev

# 前端本地运行
cd frontend && npm run dev
```

---

### 问题5: 端口被占用

**错误：**
```
Error: listen EADDRINUSE: address already in use :::3001
```

**原因：**
- Docker 容器中的后端占用了 3001 端口
- 或有其他 node 进程占用

**解决：**

**方法1：停止 Docker 容器**
```bash
docker stop ecommerce-backend
```

**方法2：查找并杀死占用进程**
```bash
# 查找占用端口的进程
lsof -ti:3001

# 杀死进程
lsof -ti:3001 | xargs kill -9
```

**方法3：检查所有 node 进程**
```bash
# 查看所有 node 进程
ps aux | grep node

# 全部清理（慎用）
pkill -9 node
```

---

### 问题6: MySQL容器未就绪

**现象：**
- Docker 显示 MySQL 容器 Running
- 但后端连接失败：`ECONNREFUSED`

**原因：**
- MySQL 容器刚启动需要时间初始化数据库
- 后端启动太早，MySQL 还未准备好接受连接

**解决：**

**等待MySQL完全启动：**
```bash
# 方法1：固定等待时间
sleep 30

# 方法2：循环检测健康状态（推荐）
for i in {1..30}; do
  if docker exec ecommerce-mysql mysqladmin ping -h localhost -uroot -proot123456 > /dev/null 2>&1; then
    echo "✅ MySQL已就绪"
    break
  fi
  echo "等待MySQL... ($i/30)"
  sleep 1
done
```

**改进建议：**
- 在启动脚本中添加健康检查
- 后端添加数据库重连机制
- 使用 Docker healthcheck

---

## 💡 后端开发最佳实践

### 1. 数据库字段一致性

**问题：**代码中使用的字段名与数据库不匹配

**解决方案：**

**开发前检查：**
```bash
# 查看表结构
mysql -e "DESCRIBE table_name;"

# 查看所有字段
mysql -e "SHOW COLUMNS FROM table_name;"
```

**使用别名：**
```sql
-- ✅ 推荐：使用 AS 别名
SELECT 
  p.*,
  c.name AS category_name,
  u.username AS user_name
FROM products p
LEFT JOIN categories c ON p.category_id = c.category_id
LEFT JOIN users u ON p.user_id = u.user_id
```

**建立映射文档：**
```markdown
| API字段         | 数据库字段    | 说明        |
|----------------|-------------|------------|
| image_url      | main_image  | 商品主图    |
| category_name  | c.name      | 分类名（别名）|
```

### 2. TypeScript类型安全

**定义清晰的接口：**

```typescript
// 数据库模型接口
export interface Product {
  product_id: number;
  title: string;
  description?: string;
  category_id: number;
  price: number;
  stock: number;
  main_image?: string;
  status: number;
  created_at: Date;
  updated_at: Date;
}

// API请求接口
export interface CreateProductRequest {
  title: string;
  description?: string;
  price: number;
  stock?: number;
  category_id: number;
  brand?: string;
  image_url?: string;
  status?: number;
}

// API响应接口
export interface ProductListResponse {
  products: Product[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}
```

**使用类型守卫：**

```typescript
function isProduct(obj: any): obj is Product {
  return (
    typeof obj.product_id === 'number' &&
    typeof obj.title === 'string' &&
    typeof obj.price === 'number'
  );
}

// 使用
if (isProduct(data)) {
  // TypeScript 知道 data 是 Product 类型
  console.log(data.product_id);
}
```

### 3. 错误处理

**统一的错误处理模式：**

```typescript
// 控制器错误处理
export const handler = async (req: Request, res: Response) => {
  try {
    // 业务逻辑
    const result = await someOperation();
    res.json({ success: true, data: result });
  } catch (error: any) {
    console.error('操作失败:', error);
    
    // 区分不同类型的错误
    if (error.code === 'ER_DUP_ENTRY') {
      return res.status(400).json({ error: '数据已存在' });
    }
    
    if (error.code === 'ER_NO_REFERENCED_ROW_2') {
      return res.status(400).json({ error: '关联数据不存在' });
    }
    
    // 通用错误
    res.status(500).json({ 
      error: '操作失败',
      message: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};
```

**全局错误处理中间件：**

```typescript
// index.ts
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error('错误:', err);
  
  res.status(500).json({ 
    error: '服务器内部错误',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
  });
});
```

### 4. 数据验证

**使用 Joi 进行参数验证：**

```typescript
import Joi from 'joi';

// 定义验证规则
const createProductSchema = Joi.object({
  title: Joi.string().required().max(200),
  description: Joi.string().optional(),
  price: Joi.number().required().positive(),
  stock: Joi.number().optional().min(0),
  category_id: Joi.number().required(),
  brand: Joi.string().optional().max(100),
  image_url: Joi.string().optional().uri(),
  status: Joi.number().optional().valid(0, 1)
});

// 在控制器中使用
export const createProduct = async (req: Request, res: Response) => {
  // 验证请求数据
  const { error, value } = createProductSchema.validate(req.body);
  
  if (error) {
    return res.status(400).json({ 
      error: '参数验证失败',
      details: error.details 
    });
  }
  
  // 使用验证后的数据
  const product = await ProductModel.create(value);
  res.json({ product });
};
```

### 5. 日志记录

**结构化日志：**

```typescript
// 使用 winston 或类似库
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

// 使用
logger.info('User login', { userId, email, ip: req.ip });
logger.error('Database error', { error: err.message, query });
```

### 6. API响应规范

**统一的响应格式：**

```typescript
// 成功响应
{
  success: true,
  data: {...},
  message: '操作成功'
}

// 错误响应
{
  success: false,
  error: '错误信息',
  code: 'ERROR_CODE',
  details: {...}  // 开发环境
}

// 列表响应
{
  success: true,
  data: [...],
  pagination: {
    page: 1,
    limit: 20,
    total: 100,
    totalPages: 5
  }
}
```

### 7. 数据库连接管理

**使用连接池：**

```typescript
import mysql from 'mysql2/promise';

const pool = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

// 封装查询函数
export async function query<T>(sql: string, params?: any[]): Promise<T> {
  const [results] = await pool.execute(sql, params);
  return results as T;
}
```

---

## 📊 后端技术栈

### 核心框架
- **Node.js 18** - 运行环境
- **Express 4** - Web框架
- **TypeScript 5** - 类型系统

### 数据库
- **MySQL 8.0** - 主数据库
- **Redis 7** - 缓存数据库
- **MongoDB 7** - 文档数据库

### 认证授权
- **JWT** - Token认证
- **Bcrypt** - 密码加密

### 工具库
- **mysql2** - MySQL驱动（Promise支持）
- **ioredis** - Redis客户端
- **mongoose** - MongoDB ORM
- **joi** - 数据验证
- **helmet** - 安全头
- **cors** - 跨域处理
- **compression** - 响应压缩

---

## 📝 开发工具和命令

### 本地开发

```bash
cd backend

# 开发模式（热重载）
npm run dev

# 编译TypeScript
npm run build

# 生产模式运行
npm start

# 数据库迁移
npm run migrate:dev

# 种子数据
npm run seed:dev
```

### Docker开发

```bash
# 只启动数据库服务
docker-compose up -d mysql redis mongodb

# 查看日志
docker-compose logs -f mysql
docker-compose logs -f redis

# 进入MySQL容器
docker exec -it ecommerce-mysql mysql -uroot -proot123456 ecommerce

# 重启服务
docker-compose restart mysql
```

### 调试技巧

**1. API测试：**
```bash
# 健康检查
curl http://localhost:3001/health

# 测试收藏API（需要token）
TOKEN="your_jwt_token"
curl -H "Authorization: Bearer $TOKEN" \
  http://localhost:3001/api/favorites/my

# 测试管理员API
ADMIN_TOKEN="admin_jwt_token"
curl -H "Authorization: Bearer $ADMIN_TOKEN" \
  http://localhost:3001/api/admin/products
```

**2. 数据库查询：**
```bash
# 查看收藏数据
docker exec ecommerce-mysql mysql -uroot -proot123456 ecommerce \
  -e "SELECT * FROM favorites LIMIT 10;"

# 查看SKU数据
docker exec ecommerce-mysql mysql -uroot -proot123456 ecommerce \
  -e "SELECT * FROM product_skus WHERE product_id = 1;"
```

**3. Redis缓存检查：**
```bash
# 进入Redis
docker exec -it ecommerce-redis redis-cli

# 查看所有key
KEYS *

# 查看商品缓存
GET product:1

# 清除缓存
FLUSHALL
```

---

## 📚 待实现功能

### 高级功能
- [ ] Elasticsearch 全文搜索集成
- [ ] RabbitMQ 消息队列集成
- [ ] 订单超时自动取消（延迟队列）
- [ ] 邮件通知系统

### 性能优化
- [ ] 数据库读写分离
- [ ] 查询结果缓存
- [ ] API响应压缩
- [ ] 限流中间件

### 安全增强
- [ ] API请求签名验证
- [ ] SQL注入防护增强
- [ ] XSS防护
- [ ] CSRF防护

---

**最后更新：** 2025年10月29日  
**后端状态：** ✅ 所有服务正常运行  
**API数量：** 50+ 个接口  
**代码质量：** ⭐⭐⭐⭐⭐

